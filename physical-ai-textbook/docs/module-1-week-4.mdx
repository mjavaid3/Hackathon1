# Week 4: Nodes, Topics, Services, and Actions - ROS 2 Communication Patterns

## Building Distributed Robotic Systems

This week focuses on the practical implementation of ROS 2's core communication primitives. You'll learn how to design and implement nodes that communicate effectively, creating the foundation for complex robotic behaviors. Through hands-on examples, you'll understand when and how to use each communication pattern.

## Deep Dive into ROS 2 Nodes

### Node Lifecycle and Best Practices

Nodes are the fundamental building blocks of ROS 2 applications. Proper node design ensures reliability, maintainability, and performance.

#### Node Initialization
```python
import rclpy
from rclpy.node import Node
from rclpy.executors import MultiThreadedExecutor
from rclpy.callback_groups import MutuallyExclusiveCallbackGroup, ReentrantCallbackGroup

class AdvancedNode(Node):
    def __init__(self):
        super().__init__('advanced_node')
        
        # Use different callback groups for concurrent execution
        self.timer_group = MutuallyExclusiveCallbackGroup()
        self.subscription_group = ReentrantCallbackGroup()
        self.service_group = MutuallyExclusiveCallbackGroup()
        
        # Initialize components
        self.initialize_parameters()
        self.create_publishers()
        self.create_subscriptions()
        self.create_services()
        self.create_timers()
        
        self.get_logger().info('Advanced node initialized successfully')
    
    def initialize_parameters(self):
        """Set up configurable parameters"""
        self.declare_parameter('update_rate', 10.0)
        self.declare_parameter('max_velocity', 1.0)
        self.declare_parameter('safety_enabled', True)
    
    def create_publishers(self):
        """Create topic publishers"""
        self.pose_publisher = self.create_publisher(
            PoseStamped, '/robot_pose', 10)
        self.status_publisher = self.create_publisher(
            RobotStatus, '/robot_status', 1)  # QoS: Keep last
    
    def create_subscriptions(self):
        """Create topic subscriptions"""
        self.cmd_vel_subscription = self.create_subscription(
            Twist, '/cmd_vel', self.cmd_vel_callback, 10,
            callback_group=self.subscription_group)
    
    def create_services(self):
        """Create service servers"""
        self.emergency_stop_service = self.create_service(
            Trigger, '/emergency_stop', self.emergency_stop_callback,
            callback_group=self.service_group)
    
    def create_timers(self):
        """Create periodic timers"""
        update_rate = self.get_parameter('update_rate').value
        self.update_timer = self.create_timer(
            1.0 / update_rate, self.update_callback,
            callback_group=self.timer_group)
    
    def cmd_vel_callback(self, msg):
        """Handle velocity commands"""
        if self.get_parameter('safety_enabled').value:
            # Apply safety limits
            msg.linear.x = max(-self.get_parameter('max_velocity').value,
                             min(msg.linear.x, self.get_parameter('max_velocity').value))
            msg.angular.z = max(-1.0, min(msg.angular.z, 1.0))
        
        # Process command
        self.process_velocity_command(msg)
    
    def emergency_stop_callback(self, request, response):
        """Handle emergency stop requests"""
        self.get_logger().warn('Emergency stop activated!')
        self.activate_emergency_stop()
        response.success = True
        response.message = 'Emergency stop activated'
        return response
    
    def update_callback(self):
        """Periodic update function"""
        # Publish current pose
        pose_msg = self.create_pose_message()
        self.pose_publisher.publish(pose_msg)
        
        # Publish status
        status_msg = self.create_status_message()
        self.status_publisher.publish(status_msg)
```

### Node Composition and Executors

ROS 2 supports different execution models for various performance requirements:

```python
def main(args=None):
    rclpy.init(args=args)
    
    # Single-threaded executor (default)
    # executor = rclpy.executors.SingleThreadedExecutor()
    
    # Multi-threaded executor for concurrent callbacks
    executor = MultiThreadedExecutor(num_threads=4)
    
    # Create nodes
    sensor_node = SensorNode()
    control_node = ControlNode()
    monitor_node = MonitorNode()
    
    # Add nodes to executor
    executor.add_node(sensor_node)
    executor.add_node(control_node)
    executor.add_node(monitor_node)
    
    try:
        # Run all nodes concurrently
        executor.spin()
    except KeyboardInterrupt:
        pass
    finally:
        # Clean shutdown
        executor.shutdown()
        sensor_node.destroy_node()
        control_node.destroy_node()
        monitor_node.destroy_node()
        rclpy.shutdown()
```

## Topics: Asynchronous Data Streaming

### Advanced Topic Usage

#### Custom Message Types
```python
# Define custom message (in msg/CustomSensor.msg)
# float64 temperature
# float64 humidity
# float64 pressure
# string status

# Publisher
class SensorPublisher(Node):
    def __init__(self):
        super().__init__('sensor_publisher')
        self.publisher = self.create_publisher(CustomSensor, '/sensor_data', 10)
        self.timer = self.create_timer(1.0, self.publish_sensor_data)
    
    def publish_sensor_data(self):
        msg = CustomSensor()
        msg.temperature = self.read_temperature()
        msg.humidity = self.read_humidity()
        msg.pressure = self.read_pressure()
        msg.status = self.get_sensor_status()
        
        self.publisher.publish(msg)
        self.get_logger().info(f'Published sensor data: T={msg.temperature:.1f}Â°C')

# Subscriber with message filtering
class SensorProcessor(Node):
    def __init__(self):
        super().__init__('sensor_processor')
        self.subscription = self.create_subscription(
            CustomSensor, '/sensor_data', self.process_sensor_data, 10)
        self.last_temperature = 0.0
    
    def process_sensor_data(self, msg):
        # Filter out invalid readings
        if msg.temperature < -50 or msg.temperature > 100:
            self.get_logger().warn(f'Invalid temperature reading: {msg.temperature}')
            return
        
        # Apply temperature smoothing
        smoothed_temp = 0.8 * self.last_temperature + 0.2 * msg.temperature
        self.last_temperature = smoothed_temp
        
        # Check for alerts
        if msg.status != 'OK':
            self.get_logger().error(f'Sensor status alert: {msg.status}')
        
        # Process valid data
        self.process_environmental_data(smoothed_temp, msg.humidity, msg.pressure)
```

#### Topic Monitoring and Debugging
```python
# Topic info and monitoring
class TopicMonitor(Node):
    def __init__(self):
        super().__init__('topic_monitor')
        
        # Monitor topic statistics
        self.topic_stats = {}
        self.create_subscription(
            PoseStamped, '/robot_pose',
            lambda msg: self.update_topic_stats('/robot_pose', msg), 10)
        
        # Periodic statistics reporting
        self.create_timer(5.0, self.report_statistics)
    
    def update_topic_stats(self, topic_name, msg):
        """Track topic statistics"""
        if topic_name not in self.topic_stats:
            self.topic_stats[topic_name] = {
                'count': 0,
                'last_time': self.get_clock().now(),
                'frequency': 0.0
            }
        
        current_time = self.get_clock().now()
        time_diff = (current_time - self.topic_stats[topic_name]['last_time']).nanoseconds / 1e9
        
        self.topic_stats[topic_name]['count'] += 1
        if time_diff > 0:
            self.topic_stats[topic_name]['frequency'] = 1.0 / time_diff
        self.topic_stats[topic_name]['last_time'] = current_time
    
    def report_statistics(self):
        """Report topic statistics"""
        for topic, stats in self.topic_stats.items():
            self.get_logger().info(
                f'{topic}: {stats["count"]} messages, '
                f'{stats["frequency"]:.1f} Hz')
```

## Services: Synchronous Communication

### Service Design Patterns

#### Parameter Query Service
```python
class ParameterService(Node):
    def __init__(self):
        super().__init__('parameter_service')
        
        # Service for getting all parameters
        self.get_params_srv = self.create_service(
            GetParameters, '/get_parameters', self.get_parameters_callback)
        
        # Service for setting parameters
        self.set_params_srv = self.create_service(
            SetParameters, '/set_parameters', self.set_parameters_callback)
    
    def get_parameters_callback(self, request, response):
        """Return current parameter values"""
        response.values = []
        for param_name in request.names:
            try:
                param_value = self.get_parameter(param_name)
                response.values.append(self.parameter_to_msg(param_value))
            except ParameterNotDeclaredException:
                self.get_logger().warn(f'Parameter {param_name} not declared')
                # Return empty value
                response.values.append(ParameterValue())
        
        return response
    
    def set_parameters_callback(self, request, response):
        """Set parameter values"""
        results = []
        for param in request.parameters:
            try:
                self.set_parameter(self.msg_to_parameter(param))
                results.append(SetParametersResult(successful=True))
            except Exception as e:
                self.get_logger().error(f'Failed to set parameter {param.name}: {e}')
                results.append(SetParametersResult(
                    successful=False,
                    reason=str(e)))
        
        response.results = results
        return response
```

#### Complex Service with Validation
```python
class MotionPlanningService(Node):
    def __init__(self):
        super().__init__('motion_planner')
        self.planner = self.create_service(
            PlanPath, '/plan_path', self.plan_path_callback)
        
        # Initialize planning components
        self.collision_checker = CollisionChecker()
        self.path_optimizer = PathOptimizer()
    
    def plan_path_callback(self, request, response):
        """Plan a collision-free path"""
        start_pose = request.start
        goal_pose = request.goal
        
        # Validate request
        if not self.validate_pose(start_pose):
            response.success = False
            response.message = 'Invalid start pose'
            response.path = Path()
            return response
        
        if not self.validate_pose(goal_pose):
            response.success = False
            response.message = 'Invalid goal pose'
            response.path = Path()
            return response
        
        # Plan path
        try:
            initial_path = self.generate_initial_path(start_pose, goal_pose)
            optimized_path = self.path_optimizer.optimize(initial_path)
            
            # Check for collisions
            if self.collision_checker.check_path(optimized_path):
                response.success = True
                response.message = 'Path planned successfully'
                response.path = self.path_to_msg(optimized_path)
            else:
                response.success = False
                response.message = 'No collision-free path found'
                response.path = Path()
                
        except Exception as e:
            response.success = False
            response.message = f'Planning failed: {str(e)}'
            response.path = Path()
        
        return response
```

## Actions: Complex Task Execution

### Action Server Implementation
```python
class ComplexTaskAction(Node):
    def __init__(self):
        super().__init__('complex_task_action')
        self._action_server = ActionServer(
            self,
            ExecuteTask,
            'execute_task',
            self.execute_callback)
        
        # Task execution components
        self.task_planner = TaskPlanner()
        self.task_executor = TaskExecutor()
        self.progress_monitor = ProgressMonitor()
    
    def execute_callback(self, goal_handle):
        """Execute complex task with feedback"""
        goal = goal_handle.request
        self.get_logger().info(f'Executing task: {goal.task_description}')
        
        # Initialize feedback and result
        feedback_msg = ExecuteTask.Feedback()
        result = ExecuteTask.Result()
        
        try:
            # Plan the task
            task_plan = self.task_planner.plan_task(goal.task_description)
            if not task_plan:
                goal_handle.abort()
                result.success = False
                result.message = 'Task planning failed'
                return result
            
            # Execute task steps
            total_steps = len(task_plan.steps)
            for i, step in enumerate(task_plan.steps):
                if goal_handle.is_cancel_requested:
                    self.get_logger().info('Task cancelled')
                    goal_handle.canceled()
                    result.success = False
                    result.message = 'Task was cancelled'
                    return result
                
                # Execute step
                step_result = self.task_executor.execute_step(step)
                
                # Update feedback
                feedback_msg.current_step = i + 1
                feedback_msg.total_steps = total_steps
                feedback_msg.step_description = step.description
                feedback_msg.progress_percentage = (i + 1) / total_steps * 100.0
                
                goal_handle.publish_feedback(feedback_msg)
                
                # Check step result
                if not step_result.success:
                    goal_handle.abort()
                    result.success = False
                    result.message = f'Step {i+1} failed: {step_result.message}'
                    return result
            
            # Task completed successfully
            goal_handle.succeed()
            result.success = True
            result.message = 'Task completed successfully'
            result.final_state = self.get_final_state()
            
        except Exception as e:
            self.get_logger().error(f'Task execution failed: {e}')
            goal_handle.abort()
            result.success = False
            result.message = f'Task execution failed: {str(e)}'
        
        return result
```

### Action Client with Complex Interaction
```python
class TaskClient(Node):
    def __init__(self):
        super().__init__('task_client')
        self._action_client = ActionClient(self, ExecuteTask, 'execute_task')
        
        # Goal tracking
        self.current_goal_handle = None
        
        # Periodic status checking
        self.create_timer(1.0, self.check_goal_status)
    
    def send_task_goal(self, task_description):
        """Send a task execution goal"""
        if not self._action_client.wait_for_server(timeout_sec=5.0):
            self.get_logger().error('Action server not available')
            return False
        
        goal_msg = ExecuteTask.Goal()
        goal_msg.task_description = task_description
        
        self.get_logger().info(f'Sending goal: {task_description}')
        
        send_goal_future = self._action_client.send_goal_async(
            goal_msg,
            feedback_callback=self.feedback_callback)
        
        send_goal_future.add_done_callback(self.goal_response_callback)
        return True
    
    def goal_response_callback(self, future):
        """Handle goal acceptance/rejection"""
        goal_handle = future.result()
        
        if not goal_handle.accepted:
            self.get_logger().info('Goal rejected by server')
            return
        
        self.get_logger().info('Goal accepted by server')
        self.current_goal_handle = goal_handle
        
        # Get result asynchronously
        get_result_future = goal_handle.get_result_async()
        get_result_future.add_done_callback(self.get_result_callback)
    
    def feedback_callback(self, feedback_msg):
        """Process feedback during execution"""
        feedback = feedback_msg.feedback
        progress = feedback.progress_percentage
        
        self.get_logger().info(
            f'Task progress: {feedback.current_step}/{feedback.total_steps} '
            f'({progress:.1f}%) - {feedback.step_description}')
    
    def get_result_callback(self, future):
        """Handle final result"""
        result = future.result().result
        self.current_goal_handle = None
        
        if result.success:
            self.get_logger().info(f'Task completed: {result.message}')
        else:
            self.get_logger().error(f'Task failed: {result.message}')
    
    def check_goal_status(self):
        """Periodic status checking"""
        if self.current_goal_handle:
            status = self.current_goal_handle.status
            if status == GoalStatus.STATUS_EXECUTING:
                # Could implement timeout logic here
                pass
```

## Integration Patterns

### Complete Robotic System
```python
class RoboticSystem(Node):
    def __init__(self):
        super().__init__('robotic_system')
        
        # Publishers for sensor data
        self.pose_pub = self.create_publisher(PoseStamped, '/robot_pose', 10)
        self.status_pub = self.create_publisher(RobotStatus, '/robot_status', 1)
        
        # Subscribers for commands
        self.cmd_sub = self.create_subscription(
            Twist, '/cmd_vel', self.velocity_callback, 10)
        
        # Services for queries
        self.get_status_srv = self.create_service(
            GetRobotStatus, '/get_robot_status', self.get_status_callback)
        
        # Actions for complex tasks
        self.navigate_action = ActionServer(
            self, NavigateToPose, '/navigate_to_pose', self.navigate_callback)
        
        # Parameters
        self.declare_parameter('max_linear_velocity', 1.0)
        self.declare_parameter('max_angular_velocity', 1.0)
        
        # Timers
        self.create_timer(0.1, self.control_loop)
        self.create_timer(1.0, self.status_update)
    
    def velocity_callback(self, msg):
        """Handle velocity commands"""
        # Apply limits and safety checks
        limited_cmd = self.apply_safety_limits(msg)
        self.execute_velocity_command(limited_cmd)
    
    def get_status_callback(self, request, response):
        """Provide robot status"""
        response.status = self.get_current_status()
        response.battery_level = self.get_battery_level()
        response.is_emergency_stop = self.is_emergency_stop_active()
        return response
    
    def navigate_callback(self, goal_handle):
        """Handle navigation goals"""
        # Implementation of navigation logic
        pass
    
    def control_loop(self):
        """High-frequency control loop"""
        # Sensor reading, state estimation, control computation
        pass
    
    def status_update(self):
        """Periodic status publishing"""
        status_msg = self.create_status_message()
        self.status_pub.publish(status_msg)
```

## Best Practices and Common Patterns

### Error Handling and Resilience
```python
def safe_callback_execution(self, callback, *args, **kwargs):
    """Execute callback with error handling"""
    try:
        return callback(*args, **kwargs)
    except Exception as e:
        self.get_logger().error(f'Callback execution failed: {e}')
        # Implement recovery logic
        self.handle_callback_error(e)
```

### Resource Management
- Use appropriate QoS settings for different data types
- Implement proper cleanup in destructors
- Monitor resource usage (CPU, memory, network)
- Handle node lifecycle events gracefully

### Testing and Validation
- Unit tests for individual components
- Integration tests for node communication
- Performance testing under load
- Failure mode testing

## Weekly Project: Integrated ROS 2 System

Build a complete robotic system that demonstrates all communication patterns:

1. **Perception Node**: Publishes sensor data (camera, LIDAR, IMU)
2. **Processing Node**: Subscribes to sensor data, performs fusion and analysis
3. **Planning Node**: Provides path planning service
4. **Control Node**: Executes motion commands via action interface
5. **Monitoring Node**: Tracks system health and performance

This project will give you hands-on experience with all ROS 2 communication primitives and their integration into a cohesive robotic system.

## Key Takeaways

1. **Nodes are the fundamental building blocks** of ROS 2 applications
2. **Choose communication patterns carefully**: topics for streaming, services for queries, actions for complex tasks
3. **Quality of Service settings are crucial** for real-time performance
4. **Proper error handling and resource management** ensure system reliability
5. **Integration testing is essential** for complex distributed systems

Next week, we'll focus on building complete ROS 2 packages and launch systems for deployable robotic applications.