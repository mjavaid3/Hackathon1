# Week 3: ROS 2 Fundamentals - The Communication Backbone

## Mastering the Robot Operating System 2

This week marks your transition from conceptual understanding to practical implementation. ROS 2 (Robot Operating System 2) serves as the communication infrastructure that enables the complex interactions required for Physical AI. You'll learn how to design, implement, and debug distributed robotic systems that can scale from simple prototypes to industrial applications.

## ROS 2 Architecture: A Distributed Nervous System

### Core Design Principles

ROS 2 is built on modern software engineering principles:

- **Distributed**: Components run on different machines or processes
- **Real-time**: Deterministic communication with quality-of-service guarantees
- **Secure**: Built-in encryption and access control
- **Cross-platform**: Support for Linux, Windows, macOS, and embedded systems
- **Modular**: Components can be mixed and matched from different sources

### Key Components

#### Nodes: The Building Blocks
Nodes are independent executable processes that perform specific functions:

```python
import rclpy
from rclpy.node import Node

class SensorNode(Node):
    def __init__(self):
        super().__init__('sensor_node')
        self.get_logger().info('Sensor node initialized')
        
        # Create a timer for periodic tasks
        self.timer = self.create_timer(1.0, self.timer_callback)
    
    def timer_callback(self):
        # Perform sensor reading and processing
        sensor_data = self.read_sensor()
        self.get_logger().info(f'Sensor reading: {sensor_data}')

def main(args=None):
    rclpy.init(args=args)
    sensor_node = SensorNode()
    rclpy.spin(sensor_node)
    sensor_node.destroy_node()
    rclpy.shutdown()

if __name__ == '__main__':
    main()
```

#### Topics: Asynchronous Communication
Topics enable one-to-many communication for streaming data:

```python
# Publisher example
class DataPublisher(Node):
    def __init__(self):
        super().__init__('data_publisher')
        self.publisher_ = self.create_publisher(String, 'sensor_data', 10)
        self.timer = self.create_timer(0.1, self.publish_data)
        self.counter = 0
    
    def publish_data(self):
        msg = String()
        msg.data = f'Data point {self.counter}'
        self.publisher_.publish(msg)
        self.get_logger().info(f'Published: {msg.data}')
        self.counter += 1

# Subscriber example
class DataSubscriber(Node):
    def __init__(self):
        super().__init__('data_subscriber')
        self.subscription = self.create_subscription(
            String,
            'sensor_data',
            self.data_callback,
            10)
    
    def data_callback(self, msg):
        self.get_logger().info(f'Received: {msg.data}')
```

### Quality of Service (QoS) Policies

ROS 2 provides fine-grained control over communication behavior:

- **Reliability**: Best effort vs. reliable delivery
- **Durability**: Volatile vs. transient local storage
- **History**: Keep last vs. keep all messages
- **Depth**: Queue size for message buffering

```python
from rclpy.qos import QoSProfile, ReliabilityPolicy, HistoryPolicy

# Real-time sensor data QoS
sensor_qos = QoSProfile(
    reliability=ReliabilityPolicy.BEST_EFFORT,
    history=HistoryPolicy.KEEP_LAST,
    depth=1
)

# Critical command QoS
command_qos = QoSProfile(
    reliability=ReliabilityPolicy.RELIABLE,
    history=HistoryPolicy.KEEP_LAST,
    depth=10
)
```

## Services: Synchronous Request-Response

Services enable direct communication between nodes:

```python
# Service server
class MathService(Node):
    def __init__(self):
        super().__init__('math_service')
        self.srv = self.create_service(AddTwoInts, 'add_two_ints', self.add_callback)
    
    def add_callback(self, request, response):
        response.sum = request.a + request.b
        self.get_logger().info(f'Incoming request: {request.a} + {request.b} = {response.sum}')
        return response

# Service client
class MathClient(Node):
    def __init__(self):
        super().__init__('math_client')
        self.cli = self.create_client(AddTwoInts, 'add_two_ints')
        while not self.cli.wait_for_service(timeout_sec=1.0):
            self.get_logger().info('Service not available, waiting...')
        self.req = AddTwoInts.Request()

    def send_request(self, a, b):
        self.req.a = a
        self.req.b = b
        self.future = self.cli.call_async(self.req)
        rclpy.spin_until_future_complete(self, self.future)
        return self.future.result()
```

## Actions: Long-Running Tasks with Feedback

Actions handle complex, interruptible operations:

```python
# Action server
class NavigationAction(Node):
    def __init__(self):
        super().__init__('navigation_action')
        self._action_server = ActionServer(
            self,
            NavigateToPose,
            'navigate_to_pose',
            self.execute_callback)
    
    def execute_callback(self, goal_handle):
        self.get_logger().info('Executing navigation goal...')
        
        feedback_msg = NavigateToPose.Feedback()
        result = NavigateToPose.Result()
        
        # Simulate navigation with progress updates
        for i in range(1, 11):
            if goal_handle.is_cancel_requested:
                goal_handle.canceled()
                return result
            
            feedback_msg.distance_remaining = 10 - i
            goal_handle.publish_feedback(feedback_msg)
            time.sleep(1)
        
        result.success = True
        goal_handle.succeed()
        return result

# Action client
class NavigationClient(Node):
    def __init__(self):
        super().__init__('navigation_client')
        self._action_client = ActionClient(self, NavigateToPose, 'navigate_to_pose')
    
    def send_goal(self, target_pose):
        goal_msg = NavigateToPose.Goal()
        goal_msg.pose = target_pose
        
        self._action_client.wait_for_server()
        self._send_goal_future = self._action_client.send_goal_async(
            goal_msg,
            feedback_callback=self.feedback_callback)
        
        self._send_goal_future.add_done_callback(self.goal_response_callback)
    
    def feedback_callback(self, feedback_msg):
        feedback = feedback_msg.feedback
        self.get_logger().info(f'Distance remaining: {feedback.distance_remaining}')
    
    def goal_response_callback(self, future):
        goal_handle = future.result()
        if not goal_handle.accepted:
            self.get_logger().info('Goal rejected')
            return
        
        self.get_logger().info('Goal accepted')
        self._get_result_future = goal_handle.get_result_async()
        self._get_result_future.add_done_callback(self.get_result_callback)
    
    def get_result_callback(self, future):
        result = future.result().result
        self.get_logger().info(f'Navigation result: {result.success}')
```

## Parameters: Runtime Configuration

Parameters allow dynamic reconfiguration without recompilation:

```python
class ConfigurableNode(Node):
    def __init__(self):
        super().__init__('configurable_node')
        
        # Declare parameters with defaults
        self.declare_parameter('sensor_rate', 10.0)
        self.declare_parameter('max_range', 5.0)
        self.declare_parameter('debug_mode', False)
        
        # Create parameter callback
        self.add_on_set_parameters_callback(self.parameter_callback)
        
        # Use parameters
        self.timer = self.create_timer(1.0 / self.get_parameter('sensor_rate').value, self.timer_callback)
    
    def parameter_callback(self, params):
        for param in params:
            if param.name == 'sensor_rate':
                # Update timer rate
                self.timer.cancel()
                self.timer = self.create_timer(1.0 / param.value, self.timer_callback)
            elif param.name == 'debug_mode':
                if param.value:
                    self.get_logger().set_level(rclpy.logging.LoggingSeverity.DEBUG)
                else:
                    self.get_logger().set_level(rclpy.logging.LoggingSeverity.INFO)
        return SetParametersResult(successful=True)
```

## Launch Files: System Orchestration

Launch files coordinate multiple nodes and set up complex systems:

```python
from launch import LaunchDescription
from launch_ros.actions import Node
from launch.actions import DeclareLaunchArgument
from launch.substitutions import LaunchConfiguration

def generate_launch_description():
    # Declare arguments
    sensor_rate_arg = DeclareLaunchArgument(
        'sensor_rate',
        default_value='10.0',
        description='Sensor publishing rate')
    
    debug_mode_arg = DeclareLaunchArgument(
        'debug_mode',
        default_value='false',
        description='Enable debug logging')
    
    return LaunchDescription([
        sensor_rate_arg,
        debug_mode_arg,
        
        # Sensor node
        Node(
            package='my_robot',
            executable='sensor_node',
            name='sensor',
            parameters=[{
                'sensor_rate': LaunchConfiguration('sensor_rate'),
                'debug_mode': LaunchConfiguration('debug_mode')
            }]
        ),
        
        # Processing node
        Node(
            package='my_robot',
            executable='processor_node',
            name='processor',
            parameters=[{
                'debug_mode': LaunchConfiguration('debug_mode')
            }]
        ),
        
        # Control node
        Node(
            package='my_robot',
            executable='control_node',
            name='controller'
        )
    ])
```

## Debugging and Monitoring

### ROS 2 Command Line Tools

```bash
# List active nodes
ros2 node list

# List topics
ros2 topic list

# Echo topic data
ros2 topic echo /sensor_data

# List services
ros2 service list

# Call a service
ros2 service call /add_two_ints example_interfaces/srv/AddTwoInts "{a: 1, b: 2}"

# Set parameters
ros2 param set /configurable_node sensor_rate 20.0

# Get parameters
ros2 param get /configurable_node sensor_rate
```

### Logging and Visualization

ROS 2 provides comprehensive logging capabilities:

```python
# Different log levels
self.get_logger().debug('Detailed debugging information')
self.get_logger().info('General information')
self.get_logger().warn('Warning about potential issues')
self.get_logger().error('Error that prevents normal operation')
self.get_logger().fatal('Critical error requiring immediate attention')
```

## Best Practices

### Node Design
- Keep nodes focused on single responsibilities
- Use descriptive names for nodes, topics, and services
- Handle exceptions gracefully
- Provide meaningful log messages

### Communication Patterns
- Choose appropriate QoS settings for your use case
- Use services for queries, topics for streaming data
- Actions for complex, interruptible operations
- Parameters for runtime configuration

### System Architecture
- Design for modularity and reusability
- Plan for distributed deployment
- Consider security implications
- Document interfaces and dependencies

## Weekly Project: ROS 2 Communication System

Build a complete ROS 2-based system with:

1. **Sensor Node**: Publishes simulated sensor data
2. **Processing Node**: Subscribes to sensor data and performs analysis
3. **Control Node**: Provides services for system control
4. **Monitoring Node**: Logs system performance and provides diagnostics
5. **Launch File**: Orchestrates all nodes with proper configuration

This project demonstrates the power of ROS 2 as a communication framework for distributed robotic systems.

## Key Takeaways

1. **ROS 2 enables distributed, real-time robotic systems** with quality-of-service guarantees
2. **Nodes, topics, services, and actions provide different communication patterns** for various use cases
3. **Parameters and launch files enable flexible system configuration** and deployment
4. **Proper debugging and monitoring are essential** for reliable robotic operation

Next week, we'll explore advanced ROS 2 concepts including lifecycle management, component composition, and real-time performance optimization.