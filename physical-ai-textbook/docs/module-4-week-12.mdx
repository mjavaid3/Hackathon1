# Week 12: Kinematics and Dynamics - The Mathematics of Motion

## Mastering the Mathematical Foundations of Humanoid Movement

This week dives deep into the mathematical foundations that enable precise control of humanoid robots. You'll learn forward and inverse kinematics, rigid body dynamics, and multi-body system modeling—essential tools for controlling complex robotic systems with human-like dexterity. Through mathematical analysis and practical implementation, you'll understand how to model, analyze, and control the sophisticated movements that make humanoid robots possible.

## Forward Kinematics: From Joints to End-Effector

### Homogeneous Transformations

The foundation of robotic kinematics lies in coordinate transformations:

```python
import numpy as np

class HomogeneousTransform:
    """Homogeneous transformation matrix utilities"""
    
    @staticmethod
    def rotation_x(theta):
        """Rotation matrix around X axis"""
        c, s = np.cos(theta), np.sin(theta)
        return np.array([
            [1, 0, 0, 0],
            [0, c, -s, 0],
            [0, s, c, 0],
            [0, 0, 0, 1]
        ])
    
    @staticmethod
    def rotation_y(theta):
        """Rotation matrix around Y axis"""
        c, s = np.cos(theta), np.sin(theta)
        return np.array([
            [c, 0, s, 0],
            [0, 1, 0, 0],
            [-s, 0, c, 0],
            [0, 0, 0, 1]
        ])
    
    @staticmethod
    def rotation_z(theta):
        """Rotation matrix around Z axis"""
        c, s = np.cos(theta), np.sin(theta)
        return np.array([
            [c, -s, 0, 0],
            [s, c, 0, 0],
            [0, 0, 1, 0],
            [0, 0, 0, 1]
        ])
    
    @staticmethod
    def translation(x, y, z):
        """Translation matrix"""
        return np.array([
            [1, 0, 0, x],
            [0, 1, 0, y],
            [0, 0, 1, z],
            [0, 0, 0, 1]
        ])
    
    @staticmethod
    def dh_transform(a, alpha, d, theta):
        """Denavit-Hartenberg transformation"""
        return HomogeneousTransform.rotation_x(alpha) @ \
               HomogeneousTransform.translation(a, 0, 0) @ \
               HomogeneousTransform.rotation_z(theta) @ \
               HomogeneousTransform.translation(0, 0, d)

class SerialManipulator:
    """Forward kinematics for serial manipulators"""
    
    def __init__(self, dh_parameters):
        """
        Initialize with DH parameters
        dh_parameters: list of (a, alpha, d, theta_offset) tuples
        """
        self.dh_params = dh_parameters
        self.num_joints = len(dh_parameters)
    
    def forward_kinematics(self, joint_angles):
        """Compute end-effector pose from joint angles"""
        
        if len(joint_angles) != self.num_joints:
            raise ValueError(f"Expected {self.num_joints} joint angles, got {len(joint_angles)}")
        
        # Start with identity matrix
        transform = np.eye(4)
        
        # Apply DH transformations sequentially
        for i, (a, alpha, d, theta_offset) in enumerate(self.dh_params):
            theta = joint_angles[i] + theta_offset
            dh_matrix = HomogeneousTransform.dh_transform(a, alpha, d, theta)
            transform = transform @ dh_matrix
        
        return transform
    
    def get_link_transforms(self, joint_angles):
        """Get transformation matrices for all links"""
        
        transforms = []
        current_transform = np.eye(4)
        
        for i, (a, alpha, d, theta_offset) in enumerate(self.dh_params):
            theta = joint_angles[i] + theta_offset
            dh_matrix = HomogeneousTransform.dh_transform(a, alpha, d, theta)
            current_transform = current_transform @ dh_matrix
            transforms.append(current_transform.copy())
        
        return transforms
```

### Humanoid Kinematics Implementation

```python
class HumanoidKinematics:
    """Complete kinematics for humanoid robot"""
    
    def __init__(self):
        # Define kinematic chains for different parts
        self.left_leg = SerialManipulator(self.get_leg_dh_params())
        self.right_leg = SerialManipulator(self.get_leg_dh_params())
        self.left_arm = SerialManipulator(self.get_arm_dh_params())
        self.right_arm = SerialManipulator(self.get_arm_dh_params())
        self.torso = SerialManipulator(self.get_torso_dh_params())
        self.head = SerialManipulator(self.get_head_dh_params())
        
        # Base transformation (floating base)
        self.base_transform = np.eye(4)
    
    def get_leg_dh_params(self):
        """DH parameters for humanoid leg (6 DOF)"""
        return [
            (0, np.pi/2, 0, 0),      # Hip yaw
            (0, -np.pi/2, 0, 0),     # Hip roll
            (0, np.pi/2, 0, np.pi/2), # Hip pitch
            (0, 0, -0.4, 0),         # Knee pitch
            (0, 0, -0.4, 0),         # Ankle pitch
            (0, -np.pi/2, 0, 0)      # Ankle roll
        ]
    
    def get_arm_dh_params(self):
        """DH parameters for humanoid arm (7 DOF)"""
        return [
            (0, np.pi/2, 0, 0),      # Shoulder yaw
            (0, -np.pi/2, 0, 0),     # Shoulder pitch
            (0, -np.pi/2, 0, 0),     # Shoulder roll
            (0, np.pi/2, -0.3, 0),   # Elbow pitch
            (0, -np.pi/2, 0, 0),     # Wrist yaw
            (0, np.pi/2, 0, 0),      # Wrist pitch
            (0, 0, -0.15, 0)         # Wrist roll
        ]
    
    def forward_kinematics_full(self, joint_angles, base_pose=None):
        """Compute poses for all end-effectors"""
        
        if base_pose is not None:
            self.base_transform = self.pose_to_transform(base_pose)
        
        # Unpack joint angles
        angles = self.unpack_joint_angles(joint_angles)
        
        # Compute end-effector poses
        left_foot_pose = self.compute_foot_pose('left', angles['left_leg'])
        right_foot_pose = self.compute_foot_pose('right', angles['right_leg'])
        left_hand_pose = self.compute_hand_pose('left', angles['left_arm'])
        right_hand_pose = self.compute_hand_pose('right', angles['right_arm'])
        head_pose = self.compute_head_pose(angles['head'])
        
        return {
            'left_foot': left_foot_pose,
            'right_foot': right_foot_pose,
            'left_hand': left_hand_pose,
            'right_hand': right_hand_pose,
            'head': head_pose
        }
    
    def compute_foot_pose(self, side, leg_angles):
        """Compute foot pose relative to base"""
        
        if side == 'left':
            leg_transform = self.left_leg.forward_kinematics(leg_angles)
            # Apply left leg offset
            leg_offset = HomogeneousTransform.translation(0.1, 0.1, 0)
        else:
            leg_transform = self.right_leg.forward_kinematics(leg_angles)
            # Apply right leg offset
            leg_offset = HomogeneousTransform.translation(0.1, -0.1, 0)
        
        return self.base_transform @ leg_offset @ leg_transform
    
    def compute_hand_pose(self, side, arm_angles):
        """Compute hand pose relative to base"""
        
        # Torso transform
        torso_transform = self.torso.forward_kinematics([0])  # Simplified
        
        if side == 'left':
            arm_transform = self.left_arm.forward_kinematics(arm_angles)
            arm_offset = HomogeneousTransform.translation(0.2, 0.2, 0.4)
        else:
            arm_transform = self.right_arm.forward_kinematics(arm_angles)
            arm_offset = HomogeneousTransform.translation(0.2, -0.2, 0.4)
        
        return self.base_transform @ torso_transform @ arm_offset @ arm_transform
```

## Inverse Kinematics: From End-Effector to Joints

### Analytical Solutions

For simple manipulators, closed-form solutions exist:

```python
class TwoLinkIK:
    """Analytical inverse kinematics for 2-link planar arm"""
    
    def __init__(self, link_lengths):
        self.l1, self.l2 = link_lengths
    
    def solve(self, target_x, target_y):
        """Solve IK for 2-link arm"""
        
        # Distance to target
        dist = np.sqrt(target_x**2 + target_y**2)
        
        # Check reachability
        if dist > (self.l1 + self.l2) or dist < abs(self.l1 - self.l2):
            return None  # Target unreachable
        
        # Elbow angle (cosine rule)
        cos_elbow = (dist**2 - self.l1**2 - self.l2**2) / (2 * self.l1 * self.l2)
        elbow_angle = np.arccos(np.clip(cos_elbow, -1, 1))
        
        # Shoulder angle
        shoulder_angle = np.arctan2(target_y, target_x) - \
                        np.arctan2(self.l2 * np.sin(elbow_angle),
                                 self.l1 + self.l2 * np.cos(elbow_angle))
        
        return [shoulder_angle, elbow_angle]

class HumanoidArmIK:
    """Inverse kinematics for humanoid arm"""
    
    def __init__(self):
        self.shoulder_pos = np.array([0.2, 0.2, 0.4])  # Relative to torso
        self.upper_arm_length = 0.3
        self.forearm_length = 0.25
        self.hand_offset = 0.15
        
        # 7-DOF arm: 3 shoulder + 1 elbow + 3 wrist
        self.dof = 7
    
    def solve(self, target_pose, current_angles=None):
        """Solve IK for 7-DOF humanoid arm"""
        
        # Extract position and orientation
        target_pos = target_pose[:3, 3]
        target_rot = target_pose[:3, :3]
        
        # Step 1: Solve for wrist position
        wrist_pos = target_pos - target_rot @ np.array([0, 0, -self.hand_offset])
        
        # Step 2: Solve 3-DOF shoulder IK
        shoulder_angles = self.solve_shoulder_ik(wrist_pos - self.shoulder_pos)
        
        # Step 3: Solve 2-DOF elbow IK
        elbow_angles = self.solve_elbow_ik(wrist_pos - self.shoulder_pos, shoulder_angles)
        
        # Step 4: Solve 3-DOF wrist IK for orientation
        wrist_angles = self.solve_wrist_ik(target_rot, shoulder_angles + elbow_angles)
        
        return shoulder_angles + elbow_angles + wrist_angles
    
    def solve_shoulder_ik(self, shoulder_to_wrist):
        """Solve 3-DOF shoulder inverse kinematics"""
        
        # Spherical coordinates
        r = np.linalg.norm(shoulder_to_wrist)
        theta = np.arctan2(shoulder_to_wrist[1], shoulder_to_wrist[0])
        phi = np.arccos(shoulder_to_wrist[2] / r)
        
        return [theta, phi, 0]  # Simplified
    
    def solve_elbow_ik(self, shoulder_to_wrist, shoulder_angles):
        """Solve 2-DOF elbow inverse kinematics"""
        
        # Project to shoulder plane
        wrist_proj = self.project_to_shoulder_plane(shoulder_to_wrist, shoulder_angles)
        
        # 2-link IK in plane
        ik_solver = TwoLinkIK([self.upper_arm_length, self.forearm_length])
        solution = ik_solver.solve(wrist_proj[0], wrist_proj[1])
        
        return solution if solution else [0, 0]
    
    def solve_wrist_ik(self, target_rot, arm_angles):
        """Solve 3-DOF wrist inverse kinematics"""
        
        # Compute current arm orientation
        arm_rot = self.forward_kinematics_arm(arm_angles)[:3, :3]
        
        # Desired wrist rotation relative to arm
        wrist_rot = arm_rot.T @ target_rot
        
        # Extract Euler angles
        roll = np.arctan2(wrist_rot[2, 1], wrist_rot[2, 2])
        pitch = np.arctan2(-wrist_rot[2, 0], 
                          np.sqrt(wrist_rot[2, 1]**2 + wrist_rot[2, 2]**2))
        yaw = np.arctan2(wrist_rot[1, 0], wrist_rot[1, 0])
        
        return [roll, pitch, yaw]
```

### Numerical Methods

For complex kinematics, numerical optimization is necessary:

```python
import scipy.optimize

class NumericalIK:
    """Numerical inverse kinematics solver"""
    
    def __init__(self, forward_kinematics_func, num_joints):
        self.fk_func = forward_kinematics_func
        self.num_joints = num_joints
        
        # Joint limits
        self.joint_limits = [(-np.pi, np.pi) for _ in range(num_joints)]
    
    def solve(self, target_pose, initial_guess=None, max_iterations=100):
        """Solve IK using numerical optimization"""
        
        if initial_guess is None:
            initial_guess = np.zeros(self.num_joints)
        
        def objective(joint_angles):
            """Minimize pose error"""
            current_pose = self.fk_func(joint_angles)
            error = self.pose_error(current_pose, target_pose)
            return error
        
        def constraint(joint_angles):
            """Enforce joint limits"""
            return np.array([
                joint_angles - np.array([lim[0] for lim in self.joint_limits]),
                np.array([lim[1] for lim in self.joint_limits]) - joint_angles
            ]).flatten()
        
        # Bounds for optimization
        bounds = self.joint_limits
        
        # Solve optimization problem
        result = scipy.optimize.minimize(
            objective,
            initial_guess,
            method='SLSQP',
            bounds=bounds,
            constraints={'type': 'ineq', 'fun': constraint},
            options={'maxiter': max_iterations, 'ftol': 1e-6}
        )
        
        if result.success:
            return result.x
        else:
            return None
    
    def pose_error(self, current_pose, target_pose):
        """Compute pose error for optimization"""
        
        # Position error
        pos_error = np.linalg.norm(current_pose[:3, 3] - target_pose[:3, 3])
        
        # Orientation error (angle between rotation matrices)
        rot_error = np.arccos(
            np.clip((np.trace(current_pose[:3, :3].T @ target_pose[:3, :3]) - 1) / 2, -1, 1)
        )
        
        # Combined error
        return pos_error + 0.1 * rot_error  # Weight orientation less
```

## Rigid Body Dynamics

### Newton-Euler Equations

```python
class RigidBodyDynamics:
    """Dynamics computation for rigid bodies"""
    
    def __init__(self, mass, inertia_tensor, com_offset):
        self.mass = mass
        self.inertia = inertia_tensor
        self.com_offset = com_offset  # Offset from joint to center of mass
        
        # State variables
        self.position = np.zeros(3)
        self.orientation = np.eye(3)
        self.velocity = np.zeros(3)
        self.angular_velocity = np.zeros(3)
    
    def compute_accelerations(self, force, torque, gravity=np.array([0, 0, -9.81])):
        """Compute linear and angular accelerations"""
        
        # Linear acceleration (F = ma)
        linear_acceleration = (force + self.mass * gravity) / self.mass
        
        # Angular acceleration (τ = Iα + ω × Iω)
        omega = self.angular_velocity
        coriolis_term = np.cross(omega, self.inertia @ omega)
        angular_acceleration = np.linalg.inv(self.inertia) @ (torque - coriolis_term)
        
        return linear_acceleration, angular_acceleration
    
    def integrate_step(self, linear_acc, angular_acc, dt):
        """Integrate accelerations to update state"""
        
        # Update velocities
        self.velocity += linear_acc * dt
        self.angular_velocity += angular_acc * dt
        
        # Update positions
        self.position += self.velocity * dt
        
        # Update orientation (simplified Euler integration)
        omega_magnitude = np.linalg.norm(self.angular_velocity)
        if omega_magnitude > 0:
            axis = self.angular_velocity / omega_magnitude
            angle = omega_magnitude * dt
            delta_rot = self.axis_angle_to_matrix(axis, angle)
            self.orientation = delta_rot @ self.orientation
    
    def axis_angle_to_matrix(self, axis, angle):
        """Convert axis-angle to rotation matrix"""
        axis = axis / np.linalg.norm(axis)
        a = np.cos(angle / 2)
        b, c, d = -axis * np.sin(angle / 2)
        
        return np.array([
            [a*a + b*b - c*c - d*d, 2*(b*c - a*d), 2*(b*d + a*c)],
            [2*(b*c + a*d), a*a + c*c - b*b - d*d, 2*(c*d - a*b)],
            [2*(b*d - a*c), 2*(c*d + a*b), a*a + d*d - b*b - c*c]
        ])
```

### Multi-Body Dynamics

```python
class MultiBodyDynamics:
    """Dynamics for articulated multi-body systems"""
    
    def __init__(self, bodies, joints):
        self.bodies = bodies  # List of RigidBodyDynamics objects
        self.joints = joints  # Joint definitions
        
        # System state
        self.q = np.zeros(self.get_num_dof())  # Joint positions
        self.qd = np.zeros(self.get_num_dof()) # Joint velocities
    
    def get_num_dof(self):
        """Get total degrees of freedom"""
        return sum(len(joint.dof) for joint in self.joints)
    
    def compute_mass_matrix(self, q):
        """Compute system mass matrix M(q)"""
        
        n = self.get_num_dof()
        M = np.zeros((n, n))
        
        # This is a simplified implementation
        # Real implementation requires recursive algorithms
        for i, body in enumerate(self.bodies):
            # Add body inertia to mass matrix
            body_inertia = body.mass * np.eye(3)  # Simplified
            M[i*3:(i+1)*3, i*3:(i+1)*3] += body_inertia
        
        return M
    
    def compute_coriolis_matrix(self, q, qd):
        """Compute Coriolis and centrifugal forces C(q,qd)"""
        
        n = self.get_num_dof()
        C = np.zeros((n, n))
        
        # Simplified - real implementation is complex
        # Involves Christoffel symbols and recursive calculations
        return C
    
    def compute_gravity_vector(self, q):
        """Compute gravity force vector G(q)"""
        
        n = self.get_num_dof()
        G = np.zeros(n)
        
        for i, body in enumerate(self.bodies):
            # Gravity acts at center of mass
            gravity_force = body.mass * np.array([0, 0, -9.81])
            # Convert to joint torques (simplified)
            G[i*3:(i+1)*3] += gravity_force
        
        return G
    
    def forward_dynamics(self, q, qd, tau):
        """Compute joint accelerations from torques"""
        
        M = self.compute_mass_matrix(q)
        C = self.compute_coriolis_matrix(q, qd)
        G = self.compute_gravity_vector(q)
        
        # Equation: M*qdd + C*qd + G = tau
        # Solve for qdd: qdd = M^-1 * (tau - C*qd - G)
        qdd = np.linalg.inv(M) @ (tau - C @ qd - G)
        
        return qdd
    
    def inverse_dynamics(self, q, qd, qdd):
        """Compute required torques for desired motion"""
        
        M = self.compute_mass_matrix(q)
        C = self.compute_coriolis_matrix(q, qd)
        G = self.compute_gravity_vector(q)
        
        # Equation: tau = M*qdd + C*qd + G
        tau = M @ qdd + C @ qd + G
        
        return tau
```

## Whole-Body Control

### Task-Space Control

```python
class WholeBodyController:
    """Whole-body control for humanoid robots"""
    
    def __init__(self, robot_model):
        self.robot = robot_model
        self.tasks = []  # List of control tasks
        
        # Null space projector
        self.null_space = None
    
    def add_task(self, task):
        """Add a control task"""
        self.tasks.append(task)
        self.update_null_space()
    
    def update_null_space(self):
        """Update null space projector for hierarchical control"""
        
        if not self.tasks:
            self.null_space = np.eye(self.robot.num_dof)
            return
        
        # Compute null space of highest priority task
        J = self.tasks[0].jacobian
        self.null_space = np.eye(self.robot.num_dof) - np.linalg.pinv(J) @ J
    
    def compute_control_torques(self, current_state, desired_tasks):
        """Compute joint torques for whole-body control"""
        
        torques = np.zeros(self.robot.num_dof)
        null_space_projector = np.eye(self.robot.num_dof)
        
        # Process tasks in priority order
        for task in self.tasks:
            # Compute task torques
            task_torques = task.compute_torques(current_state)
            
            # Project onto null space of higher priority tasks
            task_torques = null_space_projector @ task_torques
            
            # Add to total torques
            torques += task_torques
            
            # Update null space for next task
            if task.jacobian is not None:
                J = task.jacobian
                null_space_projector = null_space_projector @ \
                                     (np.eye(self.robot.num_dof) - np.linalg.pinv(J) @ J)
        
        return torques

class ControlTask:
    """Base class for control tasks"""
    
    def __init__(self, name, priority=0):
        self.name = name
        self.priority = priority
        self.jacobian = None
        self.gain = 1.0
    
    def compute_torques(self, current_state):
        """Compute torques for this task"""
        raise NotImplementedError

class PostureTask(ControlTask):
    """Maintain desired joint posture"""
    
    def __init__(self, desired_angles, kp=100, kd=10):
        super().__init__("posture")
        self.desired_angles = desired_angles
        self.kp = kp
        self.kd = kd
    
    def compute_torques(self, current_state):
        q = current_state['joint_positions']
        qd = current_state['joint_velocities']
        
        # PD control
        position_error = self.desired_angles - q
        velocity_error = -qd
        
        torques = self.kp * position_error + self.kd * velocity_error
        
        return torques

class EndEffectorTask(ControlTask):
    """Control end-effector pose"""
    
    def __init__(self, desired_pose, kp=100, kd=10):
        super().__init__("end_effector")
        self.desired_pose = desired_pose
        self.kp = kp
        self.kd = kd
    
    def compute_torques(self, current_state):
        # Compute end-effector Jacobian
        self.jacobian = self.robot.compute_ee_jacobian(current_state['joint_positions'])
        
        # Compute pose error
        current_pose = self.robot.forward_kinematics(current_state['joint_positions'])
        pose_error = self.compute_pose_error(current_pose, self.desired_pose)
        
        # Velocity error (simplified)
        velocity_error = np.zeros(6)
        
        # Task space control
        wrench = self.kp * pose_error + self.kd * velocity_error
        
        # Convert to joint torques
        torques = self.jacobian.T @ wrench
        
        return torques
```

## Weekly Project: Complete Kinematics and Dynamics System

Implement a comprehensive kinematics and dynamics system that includes:

1. **Forward Kinematics**: Complete humanoid FK with all chains
2. **Inverse Kinematics**: Numerical IK solver for arms and legs
3. **Dynamics Simulation**: Rigid body dynamics for the whole robot
4. **Whole-Body Control**: Hierarchical task control system
5. **Motion Planning**: Trajectory generation with dynamics constraints

This project will give you mastery over the mathematical foundations of humanoid motion control.

## Key Takeaways

1. **Forward kinematics transforms joint angles to end-effector poses** using DH parameters and homogeneous transformations
2. **Inverse kinematics solves for joint angles given desired poses** using analytical or numerical methods
3. **Rigid body dynamics models forces, torques, and motion** using Newton-Euler equations
4. **Multi-body systems require careful handling of constraints** between connected bodies
5. **Whole-body control manages multiple tasks hierarchically** using null space projections

Mastering kinematics and dynamics gives you the mathematical tools to control complex robotic systems with precision and physical accuracy.