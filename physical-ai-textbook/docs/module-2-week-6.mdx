# Week 6: Gazebo Simulation Environment Setup - Building Your First Digital Twin

## Mastering the Physics of Virtual Robotics

Welcome to the practical implementation of digital twin technology. This week focuses on Gazebo, the premier robotics simulator that brings physics, sensors, and environments to life. You'll learn to create virtual worlds where robots can move, sense, and interactâ€”just like in the physical world. By week's end, you'll have built your first complete digital twin.

## Gazebo Fundamentals

### What is Gazebo?

Gazebo is an open-source 3D robotics simulator that provides:

- **Realistic Physics**: Multiple physics engines (ODE, Bullet, Simbody, DART)
- **Sensor Simulation**: Cameras, LIDAR, IMUs, contact sensors
- **Environment Modeling**: Terrain, lighting, atmospheric effects
- **Plugin Architecture**: Extensible components for custom behavior
- **ROS 2 Integration**: Native support for robotic middleware

### Installation and Setup

#### Ubuntu Installation

```bash
# Add Gazebo repository
sudo apt-get update
sudo apt-get install wget
sudo sh -c 'echo "deb http://packages.osrfoundation.org/gazebo/ubuntu-stable `lsb_release -cs` main" > /etc/apt/sources.list.d/gazebo-stable.list'
wget http://packages.osrfoundation.org/gazebo.key -O - | sudo apt-key add -

# Install Gazebo
sudo apt-get update
sudo apt-get install gazebo11

# Install ROS 2 integration
sudo apt-get install ros-humble-gazebo-ros-pkgs
```

#### Verification

```bash
# Test Gazebo installation
gazebo --version

# Launch empty world
gazebo worlds/empty.world

# Test ROS 2 integration
ros2 run gazebo_ros gazebo
```

### Gazebo Interface

The Gazebo GUI consists of:

- **3D Viewport**: Main simulation view with camera controls
- **Scene Tree**: Hierarchical view of simulation objects
- **Property Panel**: Object properties and parameters
- **Toolbars**: Simulation controls (play/pause/reset)
- **Console**: Log messages and error reporting

## World Files: Creating Environments

### Basic World Structure

Gazebo worlds are defined in SDF (Simulation Description Format) XML files:

```xml
<?xml version="1.0"?>
<sdf version="1.6">
  <world name="my_first_world">
    
    <!-- Physics engine configuration -->
    <physics name="default_physics" default="true" type="ode">
      <max_step_size>0.001</max_step_size>
      <real_time_factor>1.0</real_time_factor>
      <real_time_update_rate>1000.0</real_time_update_rate>
    </physics>

    <!-- Lighting -->
    <light name="sun" type="directional">
      <cast_shadows>true</cast_shadows>
      <pose>0 0 10 0 0 0</pose>
      <diffuse>0.8 0.8 0.8 1</diffuse>
      <specular>0.2 0.2 0.2 1</specular>
      <direction>-0.5 -0.5 -1</direction>
    </light>

    <!-- Ground plane -->
    <model name="ground_plane">
      <static>true</static>
      <link name="link">
        <collision name="collision">
          <geometry>
            <plane>
              <normal>0 0 1</normal>
              <size>100 100</size>
            </plane>
          </geometry>
          <surface>
            <friction>
              <ode>
                <mu>100</mu>
                <mu2>50</mu2>
              </ode>
            </friction>
          </surface>
        </collision>
        <visual name="visual">
          <geometry>
            <plane>
              <normal>0 0 1</normal>
              <size>100 100</size>
            </plane>
          </geometry>
          <material>
            <script>
              <uri>file://media/materials/scripts/gazebo.material</uri>
              <name>Gazebo/Grey</name>
            </script>
          </material>
        </visual>
      </link>
    </model>

  </world>
</sdf>
```

### Advanced World Features

#### Terrain Modeling

```xml
<!-- Heightmap terrain -->
<model name="terrain">
  <static>true</static>
  <link name="link">
    <collision name="collision">
      <geometry>
        <heightmap>
          <uri>file://media/materials/textures/heightmap.png</uri>
          <size>100 100 10</size>
          <pos>0 0 0</pos>
        </heightmap>
      </geometry>
    </collision>
    <visual name="visual">
      <geometry>
        <heightmap>
          <uri>file://media/materials/textures/heightmap.png</uri>
          <size>100 100 10</size>
          <pos>0 0 0</pos>
        </heightmap>
      </geometry>
      <material>
        <script>
          <uri>file://media/materials/scripts/gazebo.material</uri>
          <name>Gazebo/Grass</name>
        </script>
      </material>
    </visual>
  </link>
</model>
```

#### Environmental Effects

```xml
<!-- Wind -->
<wind>
  <linear_velocity>1 0 0</linear_velocity>
</wind>

<!-- Atmospheric scattering -->
<scene>
  <sky>
    <time>10.0</time>
    <sunrise>6.0</sunrise>
    <sunset>18.0</sunset>
  </sky>
  <fog>
    <color>0.5 0.5 0.5 1</color>
    <type>linear</type>
    <start>0</start>
    <end>100</end>
    <density>0.01</density>
  </fog>
</scene>
```

## Model Files: Robot Descriptions

### URDF vs SDF

- **URDF (Unified Robot Description Format)**: XML format focused on kinematics
- **SDF (Simulation Description Format)**: Extended XML with simulation-specific features

### Basic Robot Model

```xml
<!-- basic_robot.urdf -->
<?xml version="1.0"?>
<robot name="basic_robot">

  <!-- Base link -->
  <link name="base_link">
    <visual>
      <geometry>
        <cylinder radius="0.1" length="0.2"/>
      </geometry>
      <material name="blue">
        <color rgba="0 0 1 1"/>
      </material>
    </visual>
    <collision>
      <geometry>
        <cylinder radius="0.1" length="0.2"/>
      </geometry>
    </collision>
    <inertial>
      <mass value="5.0"/>
      <inertia ixx="0.1" ixy="0" ixz="0" iyy="0.1" iyz="0" izz="0.05"/>
    </inertial>
  </link>

  <!-- Wheel links -->
  <link name="left_wheel">
    <visual>
      <geometry>
        <cylinder radius="0.05" length="0.02"/>
      </geometry>
    </visual>
    <collision>
      <geometry>
        <cylinder radius="0.05" length="0.02"/>
      </geometry>
    </collision>
    <inertial>
      <mass value="0.5"/>
      <inertia ixx="0.001" ixy="0" ixz="0" iyy="0.001" iyz="0" izz="0.001"/>
    </inertial>
  </link>

  <!-- Joints -->
  <joint name="left_wheel_joint" type="continuous">
    <parent link="base_link"/>
    <child link="left_wheel"/>
    <origin xyz="0 0.1 0" rpy="0 0 0"/>
    <axis xyz="0 1 0"/>
    <dynamics damping="0.1" friction="0.1"/>
  </joint>

</robot>
```

### Converting URDF to SDF

```bash
# Convert URDF to SDF
gz sdf -p basic_robot.urdf > basic_robot.sdf
```

## Plugins: Adding Intelligence

### Model Plugins

Model plugins attach to specific models and control their behavior:

```cpp
// Differential drive plugin
#include <gazebo/gazebo.hh>
#include <gazebo/physics/physics.hh>
#include <gazebo/common/common.hh>

namespace gazebo
{
  class DifferentialDrivePlugin : public ModelPlugin
  {
    public: void Load(physics::ModelPtr _model, sdf::ElementPtr _sdf)
    {
      this->model = _model;
      
      // Get joints
      this->leftJoint = _model->GetJoint("left_wheel_joint");
      this->rightJoint = _model->GetJoint("right_wheel_joint");
      
      // Connect to update event
      this->updateConnection = event::Events::ConnectWorldUpdateBegin(
          std::bind(&DifferentialDrivePlugin::OnUpdate, this));
    }

    public: void OnUpdate()
    {
      // Apply motor forces based on commands
      double leftVel = this->leftVelocity;
      double rightVel = this->rightVelocity;
      
      this->leftJoint->SetVelocity(0, leftVel);
      this->rightJoint->SetVelocity(0, rightVel);
    }

    private: physics::ModelPtr model;
    private: physics::JointPtr leftJoint, rightJoint;
    private: event::ConnectionPtr updateConnection;
    private: double leftVelocity = 0, rightVelocity = 0;
  };

  GZ_REGISTER_MODEL_PLUGIN(DifferentialDrivePlugin)
}
```

### World Plugins

World plugins affect the entire simulation environment:

```cpp
class WeatherPlugin : public WorldPlugin
{
  public: void Load(physics::WorldPtr _world, sdf::ElementPtr _sdf)
  {
    this->world = _world;
    
    // Create wind
    msgs::Vector3d wind;
    wind.set_x(1.0);
    wind.set_y(0.0);
    wind.set_z(0.0);
    
    // Apply wind to all models
    auto models = this->world->Models();
    for (auto model : models)
    {
      model->SetWindMode(true);
      model->SetWindLinearVelocity(wind);
    }
  }

  private: physics::WorldPtr world;
};
```

## Sensor Simulation

### Camera Sensor

```xml
<sensor name="camera" type="camera">
  <camera>
    <horizontal_fov>1.047</horizontal_fov>
    <image>
      <width>640</width>
      <height>480</height>
      <format>R8G8B8</format>
    </image>
    <clip>
      <near>0.1</near>
      <far>100</far>
    </clip>
  </camera>
  <plugin name="camera_controller" filename="libgazebo_ros_camera.so">
    <ros>
      <namespace>/camera</namespace>
      <remap from="/camera/image_raw">image_raw</remap>
    </ros>
    <camera_name>camera</camera_name>
    <frame_name>camera_link</frame_name>
  </plugin>
</sensor>
```

### LIDAR Sensor

```xml
<sensor name="lidar" type="ray">
  <ray>
    <scan>
      <horizontal>
        <samples>360</samples>
        <resolution>1</resolution>
        <min_angle>-3.14159</min_angle>
        <max_angle>3.14159</max_angle>
      </horizontal>
      <vertical>
        <samples>1</samples>
        <resolution>1</resolution>
        <min_angle>0</min_angle>
        <max_angle>0</max_angle>
      </vertical>
    </scan>
    <range>
      <min>0.1</min>
      <max>30.0</max>
      <resolution>0.01</resolution>
    </range>
    <noise>
      <type>gaussian</type>
      <mean>0.0</mean>
      <stddev>0.01</stddev>
    </noise>
  </ray>
  <plugin name="lidar_controller" filename="libgazebo_ros_ray_sensor.so">
    <ros>
      <namespace>/lidar</namespace>
      <remap from="/lidar/scan">scan</remap>
    </ros>
    <frame_name>lidar_link</frame_name>
  </plugin>
</sensor>
```

### IMU Sensor

```xml
<sensor name="imu" type="imu">
  <imu>
    <angular_velocity>
      <x>
        <noise type="gaussian">
          <mean>0</mean>
          <stddev>0.001</stddev>
        </noise>
      </x>
      <y>
        <noise type="gaussian">
          <mean>0</mean>
          <stddev>0.001</stddev>
        </noise>
      </y>
      <z>
        <noise type="gaussian">
          <mean>0</mean>
          <stddev>0.001</stddev>
        </noise>
      </z>
    </angular_velocity>
  </imu>
  <plugin name="imu_controller" filename="libgazebo_ros_imu_sensor.so">
    <ros>
      <namespace>/imu</namespace>
      <remap from="/imu/data">data</remap>
    </ros>
    <frame_name>imu_link</frame_name>
  </plugin>
</sensor>
```

## ROS 2 Integration

### Launching Gazebo with ROS 2

```python
# launch/gazebo.launch.py
from launch import LaunchDescription
from launch_ros.actions import Node

def generate_launch_description():
    return LaunchDescription([
        Node(
            package='gazebo_ros',
            executable='gazebo',
            arguments=['-s', 'libgazebo_ros_factory.so'],
            parameters=[{'world_name': 'my_world'}],
        ),
        Node(
            package='gazebo_ros',
            executable='spawn_entity.py',
            arguments=['-entity', 'my_robot', '-file', '/path/to/robot.urdf'],
        ),
    ])
```

### Controlling Simulation from ROS 2

```python
# Simulation control node
class SimulationController(Node):
    def __init__(self):
        super().__init__('simulation_controller')
        
        # Service clients for simulation control
        self.pause_client = self.create_client(Empty, '/pause_physics')
        self.unpause_client = self.create_client(Empty, '/unpause_physics')
        self.reset_client = self.create_client(Empty, '/reset_simulation')
        
        # Publishers for model control
        self.model_state_pub = self.create_publisher(
            ModelState, '/gazebo/set_model_state', 10)
    
    def pause_simulation(self):
        """Pause the physics simulation"""
        req = Empty.Request()
        self.pause_client.call_async(req)
    
    def set_model_pose(self, model_name, pose):
        """Set the pose of a model in simulation"""
        msg = ModelState()
        msg.model_name = model_name
        msg.pose = pose
        self.model_state_pub.publish(msg)
```

## Performance Optimization

### Real-Time Factor Management

```xml
<!-- World configuration for real-time performance -->
<physics name="default_physics" default="true" type="ode">
  <max_step_size>0.001</max_step_size>
  <real_time_factor>1.0</real_time_factor>
  <real_time_update_rate>1000.0</real_time_update_rate>
  <gravity>0 0 -9.81</gravity>
</physics>
```

### Level of Detail (LOD)

```xml
<!-- Distance-based LOD -->
<visual name="high_detail">
  <geometry>
    <mesh>
      <uri>model://robot/meshes/high_detail.dae</uri>
    </mesh>
  </geometry>
  <plugin name="lod" filename="libLodPlugin.so">
    <distance>10.0</distance>
    <mesh>model://robot/meshes/low_detail.dae</mesh>
  </plugin>
</visual>
```

## Weekly Project: Complete Digital Twin

Create a comprehensive Gazebo simulation that includes:

1. **Custom World**: Environment with terrain, lighting, and atmospheric effects
2. **Robot Model**: Complete URDF/SDF description with accurate physics properties
3. **Sensor Suite**: Camera, LIDAR, and IMU sensors with realistic noise models
4. **ROS 2 Integration**: Launch files and control nodes for simulation interaction
5. **Plugin Development**: Custom plugins for robot control and environmental effects

This project establishes the foundation for all subsequent simulation-based development in your Physical AI journey.

## Key Takeaways

1. **Gazebo provides realistic physics simulation** essential for Physical AI development
2. **World and model files define simulation environments** with SDF/URDF formats
3. **Plugins extend functionality** for custom behavior and sensor models
4. **ROS 2 integration enables seamless control** of simulated systems
5. **Performance optimization ensures real-time operation** for interactive development

Next week, you'll extend these concepts by integrating Unity for high-fidelity visualization and exploring advanced simulation techniques for AI training.